# Git 与 GitHub 快速上手教程
> <i class="fas fa-exclamation-triangle"></i> 本文档还在编辑之中。![progress-50%25-yellow](shield)
> 
> 最后修改时间： 2019年7月29日
> 
> 参与编辑：[![自动化钱71吴思源](person)](@edmundwsy)，[![能动少C71尤佳睿](person)](@xjtu-blacksmith)

## 1 什么是 Git 与 GitHub？
GitHub 名声在外，已经不是一两年了；但是，许多人并不清楚这是怎样的一个“网站”。那么，GitHub 是做什么的呢？

说到 GitHub，很显然不能不讨论 Git。[Git](https://git-scm.com) 是一个**版本控制软件**，这类软件能够精确的记录制定目录下代码的增删变动，在必要时允许还原到原来的状态。当然，对 Git 而言，其还有许多特有的功能，在此暂不详述[^0]。Git 并不仅仅只是一个在本地运行的软件，它能够实现分布式的版本控制——也就是说，通过一个远程的**代码托管平台**，Git 可以帮助程序员实现多个分立终端上的共同开发、信息交互与同步，从而可以实现多人协作。

[GitHub](https://github.com) 则正是一个基于 Git 而建立的**在线代码托管平台**，用户可以在其上建立属于自己或与他人共享的**代码仓库**，并在此基础上实现版本控制、团队协作，甚至开源软件发布、网站建设、文档维护等诸多超出 Git 固有功能以外的事情。至 2019 年四月，GitHub 上已托管超过一亿个开源代码仓库，有超过 3600 万名用户活跃其中[^1]。

GitHub 的出现[^2]，使我们不再担心备份与远程协作：一切提交，均有记录。

> 更现实的一个需求是：通过 GitHub，你就再也不用和这样的东西打交道了：
> 
> - `网页设计初稿.html`
> - `网页设计初稿-某某批注.html`
> - `网页设计初稿-某某批注-二改.html`
> - `网页设计终稿.html`
> - `网页设计终极稿.html`
> - ……
> 
> 存一个文件就够了：`网页设计.html`。GitHub 会帮你记录所有的版本，你还可以轻松的比对各版本之间的差异。

## 2 Git 是怎么运作的
GitHub 是基于 Git 的代码托管平台，所以我们仍然需要了解 Git 的运作机制。以下内容并不涉及复杂的工作原理，仅是对 Git 运行机制的大致描摹。

> <i class="fas fa-forward"></i> 如果你对枯燥无味的概念感到厌烦，可以先跳到第 3 节“GitHub 指南”进行一些尝试，再在需要时到本节补充相关知识。

Git 是一个**版本控制系统**，即可以记录一个目录（文件夹）下各个文件的增删改动情况，并允许用户回溯历史、修改或撤销之前的操作。不同的版本控制系统，对于这些功能有着不同的实现方式、不同的运作原理与不同的术语（称呼）；对 Git 的用户而言，需要熟悉以下一些概念。

### 2.1 文件储存区域

在使用 Git 管理代码仓库/文件夹时，存在着三个所谓的区域：工作区域（简称工作区）、暂存区域（简称暂存区）、本地仓库（简称版本库）。其中：

- **工作区**就是当前的各种文件所在的区域，就是**实实在在**地存在你的文件夹里、能从系统的窗口里看到的内容。
- **暂存区**是一个由Git通过所谓“索引文件”创设出来的**虚构区域**，其所存放的是一些被你要求“**记录在案**”但尚未确定去留的文件。例如，你在一份数据表格中新增了一条数据，希望在将来把这条记录发布到新版本中，但你还没有完成需要同时发布的其他文件。这时，你可以在 Git 中通过暂存操作将这条改动先记录下来，以待将来提交/发布，或仅仅只做一个暂时的记录。
- **版本库**则是 Git 根据当前目录的各个**版本**而创建的一个**虚构区域**，它也算是真实存在，但却是以一种我们所不能手动处理或修改的压缩文件形式存储在当前文件夹下的（存放在名为`.git`的一个隐藏文件夹中）。版本库记录着那些已经由你所正式发布的文件版本与内容。与暂存区不同的是，版本库中所记录的文件版本、改动记录已经被固结，只能撤销、删除，但不能修改。特别地，在远程平台——如GitHub上——所留存的文件，都是以版本库的形式存在的。

读者可能会问：为什么做版本控制需要三个区域来记录呢？为了方便理解，有这样一个例子可供参考：

> 你是一个美食博主。今天你心情不错，打算精心准备一桌菜，然后再拍照发布。在准备的过程中：
> 
> - 你所烹饪出来的、摆在饭桌上的菜，真实存在，这张饭桌便是所谓的**工作区**；
> - 你是一个心思细腻的人，不光期待着结果，还随时用手机记录做饭过程中各个阶段的状况。这些由你在不同时间拍下来的照片，“记录”了你所烹饪的菜品之“改动”；而存储着这些照片的手机空间，就是所谓的**暂存区**；
> - 烹饪渐近尾声，桌上的菜品玲琅满目，你的手机里也储存了许多或好或坏的照片。这时，你可以对你的照片仔细筛选，最终挑选出一组完美的“九图大法阵”；配上一段文字说明，你轻按微博界面上的“发布”按钮，一条新的微博就经由你手机上的一个本地数据库传递到微博平台的服务器上，进而可以在整个互联网上看到。你所最终发布的这条微博，便是代码管理过程中所谓的“版本”；储存着这些微博的本地数据库和远程服务器，就是所谓的**版本库**。
> 
> 很显然，在以上三个储存区中，只有工作区储存着真正的美食，而暂存区和版本库记录的不过是照片——在代码管理过程中，相应的事物则叫做“快照”。至于为什么要在工作区与版本库之间多加上暂存区这一环节，打一个比方便是：如果你用手机拍的每一张照片都会自动发布在微博上，你还敢轻易的拍照片吗？还能“仔细筛选”吗？

当然，以上的这个例子，与 Git 的实际运作方式仍有很大不同。最大的不同在于：在现实世界中，你不能通过手机或微博上的照片把真实的菜品还原出来；而在 Git 中，代码版本管理的最大意义，恰在于你总是可以由**版本库**（有时也可以是**暂存区**）还原、覆盖你的**工作区**。这样，在代码的编写过程中若出现问题，随时可以还原回之前的状态；同时，你也可以调出一段时间以前的老版本，执行对比、检查、多分支开发（从一个相同的版本结点上分道扬镳，开发出不同的软件，这是开源社区常常出现的事情）等诸多功能。

为了理清这三者的关系，读者不妨先从下面这几条原则开始：

1. 工作区就是电脑窗口上看到的东西，存在硬盘里。
2. 暂存区和版本库都是“看不见”的，它们以特殊文件的形式存在于工作区中一个名为 `.git` 的神秘文件夹之下。
3. 工作区中的文件必须先记录到暂存区中，才能再由暂存区发布到版本库内；工作区的文件无法直接进入版本库。
4. 暂存区和版本库都可将工作区内的文件直接覆盖。
5. GitHub 上发布的文件以版本库存在；或者说，GitHub 就是一个在线储存版本库的平台，而并不像工作区那样直接储存文件。
6. 版本库中确实记录了很多版本，工作区和暂存区则并不负责此事。

絮叨这么多废话，读者不妨通过以下这张图片来加深对这三个区域之关系的理解。其中，所谓的远程仓库与（本地）版本库是使用相同的方式存储的，只不过前者储存在网络上，而后者储存在用户自己的电脑上。

![三区示意图](https://zhouhao.me/img/git_reset_20170826.png)

<p style="text-align: center"><small>(图片来源：<a href="https://zhouhao.me/2017/08/27/detailed-explanation-of-git-reset/">Git 学习笔记 - git reset 详解</a>，作者：<a href="https://github.com/howzy">howzy</a>)</small></p>

### 2.2 版本管理命令
观察上面所给出的示意图，读者可以发现其中用若干箭头标明了文件流转的方向，并注有对应的英文说法。例如，文件从工作区记录到暂存区的操作，被称作`add`；而将暂存区中的记录正式提交到版本库内，则被称作`commit`。这些英文词汇，就是在 Git 客户端中需要调用的**命令名称**。对于初级用户而言，以下几个操作是需要牢记在心的：

命令|字面意思|行为
:-:|:-:|---
`clone`|“复制”、“克隆”|将一个发布在远程仓库[^3]（如 GitHub）上的版本库复制到本地。这通常是参与代码协作的第一步。
`init`|“初始化”|在本地的一个空目录下新建版本库。与`clone`的实际效果是相近的，只不过来源不同而已。此命令很少用到。
`add`|“添加”|将工作区的文件改动记录到暂存区。这是将一个文件发布到正式版本之前不可跳过的一步。
`commit`|“记录”、“交付”|将所有记录在暂存区的文件改动发布于版本库中；与`add`不同的是，在`commit`时必须对这次发布的内容进行必要的说明（称为 commit message），且`commit`一旦提交就只能删除，而不能再修改这次的发布记录。`commit` 也常被作为一个名词来使用。
`push`|“推”、“推送”|将本地版本库的内容发布到远程版本库（如 GitHub）上。能够正确`push`的前提是：本地版本库的版本**超前**于远程版本库。
`pull`|“拉”、“拉取”|将远程版本库的更新同步到本地的版本库**与工作区**。一般而言，执行`pull`的原因是：本地版本库的版本**落后**于远程版本库。

以上几个操作中，`init`、`add` 与 `commit` 都是不需要网络而在本地执行的操作，剩余的则需要与远程平台交互。读者可以再回看上面演示区域交互的示意图，以加深对这些命令的感受。

### 2.3 版本控制流程
看过 Git 的三大区域与若干操作命令后，Git 做的事情就可以只需要几句话来说清楚了。当然，Git 本身只是一个工具，有很多的“玩法”；但在一般的软件、代码、文档开发流程中，Git 的使用一般遵循着下面的几个步骤：

1. 在 GitHub 上找到一个他人已经有所开发的代码仓库，并在本地的 Git 客户端用 `clone` 命令复制到自己的电脑上。（注意，对于已经**公开**的仓库，`clone` 之前并不需要登录或取得权限，就像“免费下载”一样。）经过此操作，你便在本地获得了一个版本库和与之同步的工作区。
2. 你可以在工作区中按需要做任意的改动，参与协作。（记得随时保存文件， Git 并不会负责这件事情。）
3. 完成（或部分完成）你所要做的工作后，执行 `add` 操作以将你所做的改动记录进暂存区。
4. 所有你所需要的改动都暂存之后，就可以由 `commit` 操作正式发布到版本库中——记得认真填写 commit message。
5. 在你修改文件的同时，你的同伴也许已经在千里之外的一台电脑上修改了其他的文件，甚至已经先于你一步将这些改动发布到 GitHub 上了。为了保持与远程仓库的同步，你需要在将你的改动发布前再耐心地执行一次 `pull` 操作，以确认自己的改动与其他人的改动并无冲突，并将他人的改动纳入到你的版本库中。如果你的改动不幸的与他人的改动发生了**冲突**，你就还需要额外做一些工作了——这一步骤将在之后进一步讨论。
6. 与目前的远程仓库同步成功后，你就可以通过 `push` 操作将自己的改动全数发布到 GitHub 上，一次版本更新至此告一段落。

> 以上步骤之中，第一步显然只需要执行一次；在以后的写作过程中，你只需要及时用 `pull` 命令与远程仓库保持同步即可。

上面所给出的这些步骤，并不是一个必须遵守的范式。例如，如果你在独自开发一个仓库（并未与他人协作），并且只从一个客户端使用 Git 工具，则上面所说的第五步（`pull`）便是多余的。又如，为了使自己的改动清晰明了，你可以将对一份文件的多处更改或多份文件的更改手动拆解到若干个不同的 `commit` 之中，就像发微博的时候将一系列照片分好几条微博发送一样。

代码版本控制就这样几步，并不需要很多的技巧。对于大多数人来说，控制版本不算难题，难题在于不会写代码，没东西发、不敢发。（~~我不是在针对你，我是说在座的各位，都是……~~）

### 2.4 Git 特色：分支管理
与 Git 相仿的版本控制软件，不在少数。与其他工具相较，Git 却具有一个特殊的机制：分支管理；这项功能，可以说是对过去许多年来软件开发流程之经验的总结，对程序的开发是非常有帮助的。

> 如果读者想初步了解一下分支管理的价值，可读阮一峰的一篇博客：[Git分支管理策略](http://www.ruanyifeng.com/blog/2012/07/git.html)。

在学辅，并没有程序开发的需要，通常所做的是文档和简单代码的协作；尽管如此，由于分支机制是 Git 的一项基础，这里仍需要做一些简单的说明。

所谓分支（branch），就是一系列前后相贯的版本所构成的整体，它本是版本管理过程中一个常常出现的现象、范畴。例如，两位作者经由同一份原始的代码发展、开发出两个不同的程序，则这两个程序的源代码就属于两个分支；它们有着相同的起点、有若干公用的版本，但在某一个版本结点时便分道扬镳了。分支的创建不一定总是分道扬镳的过程；对同一个开发小组而言，他们可能会将代码开发主动分散到不同的分支上，同时又经常地将分支进行合并（merge），以此满足不同的需要。

作为 Git 的一项特色机制，其将代码开发过程中的分支给实体化了（也就是说，在 Git 中，分支是真实存在的对象，而不再是一个抽象的范畴），并鼓励使用者利用分支机制下提升开发体验。在 Git 中，通常有一个主分支，其名称为 `master` 。如无特殊情况，所有代码改动都只需要在 `master` 上提交即可。如果需要进行多分支开发，则可以新创建一些分支，在这些新的分支上进行开发；再在合适的时候，将这些分支上的改动汇入 `master` 分支。这样做的好处是：`master`的改动不会太过频繁，所有的改动都是在经开发人员测试无误之后在发布在用户可见的 `master` 分支上，这样能够提高代码的稳定性。

> 在学辅的代码协作过程中，通常只会使用 `master` 分支。具体原因，将在下一节提到。

## 3 GitHub 指南
对于新手来说，Git 似乎是一个“高深莫测”的工具，牵涉许多新的机制；对于将来没有“改行”意向的计算机小白而言，更是无法挤出时间、下定决心钻研这样一个看似距离他们很遥远的技术工具。事实上，如果仅仅是希望用 GitHub 实现基本的文档或代码协作，则不必如此大费周折，只需在 GitHub 的网页或客户端上操作就已足够。下面，针对这一部分内容作简单的讲解。

开始之前，需要先完成下面的两项工作：

- [注册 GitHub](https://github.com/join)；
- 如果你希望以**小白**的身份获得 GitHub 的最佳体验，可以尝试[下载 GitHub 客户端](https://desktop.github.com)（正式名称为 GitHub Desktop）。当然，这一步可以略去不做，这样的后果是：你只能在网页上创建或上传文件，而不能建立起远程仓库与本地仓库的联系。

由于一些原因，GitHub 在国内访问时速度并不很快，常常掉线或中断连接。针对这种情况，你有两种选择：

1. 访问 GitHub 网页、上传文件时，学会更加耐心~~或者充分利用加载的时间完成泡茶、点外卖、洗衣服、写作业等闲杂事项~~；
2. 自备梯子。（[梯子是什么？](https://hanyu.baidu.com/zici/s?wd=梯子) [怎样做梯子？](https://jingyan.baidu.com/article/b87fe19e5c125d5218356836.html) [有哪些好的梯子？](https://list.tmall.com/search_product.htm?q=梯子)）

### 3.1 创建新的仓库
在注册 GitHub 之后，网站通常会建议你阅读一份名为 [Hello World](https://guides.github.com/activities/hello-world/) 的指南（以下简称“指南”），帮助你建立一个名为 `hello-world` 的仓库。这是一个很好的练习，此处将给予一些额外的说明。

创建仓库时，指南要求你按以下的配置创建仓库：

![init settings](https://guides.github.com/activities/hello-world/create-new-repo.png)

<p style="text-align: center"><small>(图片来源：<a href="https://guides.github.com/activities/hello-world/">Hello World · GitHub Guides</a>)</small></p>

这里的几个选项值得说明：

- Owner 即仓库所有者的名字——一般情况下，所有者是你自己，但也可以是你管理的组织（如`qyxf`）。
- Repository name 是仓库的名字。按照目前惯例，一般采用连接线命名方法（如`hello-world`），但也可以使用驼峰命名法或 Pascal 命名法（如`BookHub`）。风格统一即可。
- 以上的 Owner 及 Repository name，决定了代码仓库的地址。例如，`qyxf`的`BookHub`仓库，网页地址便是 [https://github.com/qyxf/BookHub](https://github.com/qyxf/BookHub)。
- Description 是 GitHub 页面上显示的仓库描述，与代码无关。尽管是 optional 的，还是建议用户认真填写。
- Public （公开）与 private （私有）决定了仓库的可见性。公开仓库可以为所有人看到，无论他们是否登录了 GitHub；而私有仓库只能为仓库所有者和其所许可的其他 GitHub 用户访问、克隆、修改。过去，GitHub 的私有仓库是收费项；在微软收购 GitHub 之后不久，三人以下协作的私有仓库可以免费使用。此外，仓库的可见性可以在创建之后修改，所以不用担心最开始的选择。
- 指南中要求你“Initialize with a README”，即在你新建的仓库中自动生成一份名为`README`的 Markdown 文档（这是什么？）。`README`相当于这个仓库的说明，会由 GitHub 自动展示在仓库的首页，当然有必要创建；不过，这里创建这份文件还有另一个作用——由此创建的仓库，不是空的，便于你通过 `clone` 命令直接复制到本地，也便于 GitHub 配置相关的属性。

> 如果你不打算使用 Git 客户端，请**务必**在创建仓库时初始化 `README`。（~~跳过这一步的人都后悔了。~~）

之后，指南按照 GitHub 所推荐的分支管理模式来，指导你如何在独立于 `master` 分支的侧分支上修改文件，并通过名为 Pull request 的操作（这并不是 Git 中的固有机制）将其合并到 `master` 内。在一般的代码协作中，仓库内的分支管理机制不常被使用，读者可以在自己的仓库中稍作尝试；而 Pull request 则尤为重要，是代码协作的关键，在 3.4 节中将详细介绍。

### 3.2 玩转自己的仓库
创建新的仓库之后，你就可以在 GitHub 网页端开始编辑。开始之前，有件事值得注意：

> 与 Git 客户端不同，GitHub 的网页端与客户端都没有暂存区的概念。其中，网页端上只能同时编辑一个文件，且每次改动后都必须为之提交一个单独的 `commit`（不能分批或扎堆）将改动直接记录到版本库中；客户端则只能直接将工作区中的所有改动一次性 `commit` 至版本库，或丢弃工作区的改动。

这一特性，在某种意义上来说是 GitHub 为 Git 门外汉们搭设的“终南捷径”；尽管暂存区的缺失使精细管理变得困难，但却同时降低了 GitHub 的使用门槛。理解这种差异，对于 GitHub 的用户来说是十分重要的；一般来说，即使是 Git 高手也偶尔会直接在 GitHub 网页端直接操作，因此理解两者的差异是必要的。

在网页端，可通过三种方式对仓库作出改动：

- 通过仓库页面上的“Create new files”按钮创建新的代码文件，GitHub 将根据你所给定的后缀名自动确定代码所用的语言。
- 通过仓库页面上的“Upload files”按钮上传本地文件。根据本节开头所说的原因，不推荐这种做法——超过 1M 的文件难以在国内成功上传。
- 通过仓库内各文档页面上的 <i class="fas fa-pencil-alt"></i> 按钮编辑文档。

无论是用哪种方式，都必须在保存改动前填写 commit message。网页端的功能较为有限，故其一般只用于创建与修改 Markdown 文档这样的简单内容。

使用 GitHub 客户端是一个更好的选择。

### 3.3 参与协作

### 3.4 体验 GitHub 客户端

## 4 Git 指南：进入深水区
在开始下面的内容之前，首先需要[下载 Git](https://git-scm.com/downloads) 并安装之（或许你还需要一份[安装教程](https://git-scm.com/book/zh/v2/起步-安装-Git)）。

### 4.1 本地创建
在Git页面中，输入命令

    git clone /path/to/repository


即可创建一个本地仓库的克隆版本（从现有的仓库中拷贝）。而

    git init

可从本地创建新目录。

初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。

### 4.2 加入文件
    git add ./Handout3.tex

当然还有其它的选项，比如add文件夹里面所有文件

    git add --all


### 4.3 提交
    git commit -m "Adding files"

将修改提交版本库

- 工作区：就是你在电脑里能看到的目录。
- 暂存区：英文叫stage, 或index。一般存放在 ".git目录下" 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。
- 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。

### 4.4 与远程同步

    git remote add origin git@github.com:edmundwsy/new.git

将本地库与远程关联

    git remote remove origin

取消关联

    git clone https://github.com/qyxf/Tutorials.git

将我们远程的repo克隆至本地

    git pull

拉取远程更新，以在你的工作目录中 *获取（fetch）* 并 *合并（merge）* 远端的改动。

    git push origin master

    git push <远程主机名> <本地分支名>  <远程分支名>

即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名，

    git push -h

### 4.5 设置公钥

    git config --global user.name "My Name" 
    git config --global user.email myEmail@example.com

如果报错

```powershell
$ git push origin master                                 
git@github.com: Permission denied (publickey).
```

在GitHub设置远程公钥就可以解决这个问题

在GitHub网页端：Setting -> SSH Keys->New SSH key

- title处填写：`id_rsa.pub`
- `cat ~/.ssh/id_rsa.pub`
  - 若没有，则`ssh-keygen -t rsa`
  - 一路回车......
  - 最后，输入`ssh -T git@github.com`确认OK即可。
- 然后把这个复制到GitHub中，保存
- 再尝试就ok了

再解决不了了估计就是没有权限了。。。。。。请联系仓库管理员

### 4.6 分支


    git checkout -b feature_x

创建一个叫做“feature_x”的分支，并切换过去：

    git checkout master

切换回主分支：

    git branch -d feature_x

再把新建的分支删掉：

    git push origin <branch>

除非你将分支推送到远端仓库，不然该分支就是 *不为他人所见的*

### 4.7 合并分支


要合并其他分支到你的当前分支（例如 master），执行：

    git merge <branch>

在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现*冲突（conflicts）*。 这时候就需要你修改这些文件来手动合并这些*冲突（conflicts）*。改完之后，你需要执行如下命令以将它们标记为合并成功：

    git add <filename>

在合并改动之前，你可以使用如下命令预览差异：

    git diff <source_branch> <target_branch>

### 4.8 历史记录

如果你想了解本地仓库的历史记录，最简单的命令就是使用: 

    git log

你可以添加一些参数来修改他的输出，从而得到自己想要的结果。 只看某一个人的提交记录:

    git log --author=bob

一个压缩后的每一条提交记录只占一行的输出:

    git log --pretty=oneline

或者你想通过 ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签: 

    git log --graph --oneline --decorate --all

看看哪些文件改变了: 

    git log --name-status

这些只是你可以使用的参数中很小的一部分。更多的信息，参考：

    git log --help

## 5 一些问题
> 冲突怎么办？

合并分支，手动修改。建议先把自己的提交，然后`pull`，最后`commit`，可最大程度减少冲突的几率。

## 6 其它教程
以下这些教程较这里的更为详细，值得进一步阅读。

- [git 简明指南](http://rogerdudler.github.io/git-guide/index.zh.html)
- [菜鸟教程 - git教程](http://www.runoob.com/git/git-tutorial.html)
- [廖雪峰Git教程](
https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)

最后，在熟悉了GitHub的基本使用方法后，别忘了关注我们的作品！

- [钱院学辅的GitHub主页](https://github.com/qyxf)
- [钱院学辅书库（BookHub）](https://github.com/qyxf/BookHub)

<!--- 引用 --->
[^0]: 想要详细的学习Git的使用，可参考Git的官方在线教程：[Pro Git](https://gitee.com/progit/index.html)——这里提供的是[码云](https://gitee.com/)上的中文翻译。
[^1]: 数据来自于：[GitHub自述页面](https://github.com/about)，查看于2019年6月13日。
[^2]: 准确地说，Git并非较早诞生的版本控制软件，GitHub也远非最早的远程开源仓库（更早者有[SourceForge](https://sourceforge.net)、[Launchpad](https://launchpad.net/)等），但GitHub可以说是首次让**开源仓库**这个概念冲出了程序员的小圈子。
[^3]: `clone`操作对本地的版本库同样有效——例如，你可以用此命令将一个在此目录下的版本库拷贝到彼目录。当然，一般并没有人做这样的事情。